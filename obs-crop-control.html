<!DOCTYPE html>
<!--
**
**  OBS-Crop-Control ~ Remote Crop-Filter Control for OBS Studio
**  Copyright (c) 2021 Dr. Ralf S. Engelschall <rse@engelschall.com>
**  Distributed under GPL 3.0 license <https://spdx.org/licenses/GPL-3.0-only.html>
**
-->
<html>
    <head>
        <title>OBS-Crop-Control</title>
        <meta charset="UTF-8"/>
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link rel="preconnect" href="https://cdn.jsdelivr.net">
        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" rel="stylesheet">
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vue@3.2.26/dist/vue.global.prod.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/obs-websocket-js@4.0.3/dist/obs-websocket.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3-ease@3.0.1/dist/d3-ease.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mousetrap@1.6.5/mousetrap.min.js"></script>
        <style type="text/css">
            html, body {
                margin: 0;
                padding: 0;
                user-select: none;
            }
            body {
                color: #f0f0f0;
                font-family: "Source Sans Pro";
                display: flex;
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }
            .canvas {
                display: flex;
                flex-direction: column;
                align-items: center;
                position: relative;
                background-color: #202020;
            }
            .canvas .toolbar {
                position: absolute;
                bottom: 1vw;
                right: 1vw;
                display: flex;
                flex-direction: row;
            }
            .canvas .toolbar .define {
                padding: 0 2vw 0 2vw;
                background-color: #666666b0;
                color: #ffffff;
                font-weight: bold;
                border-radius: 1vw;
                font-size: 4vw;
                margin-left: 1vw;
            }
            .canvas .toolbar .button {
                width: 5vw;
                padding: 0 2vw 0 2vw;
                background-color: #666666b0;
                color: #ffffff;
                font-weight: bold;
                border-radius: 1vw;
                font-size: 4vw;
                margin-left: 1vw;
            }
            .canvas .cropCurr {
                position: absolute;
                display: flex;
                flex-direction: column;
                align-items: center;
                box-sizing: border-box;
                border: 1vw solid #00cc00b0;
            }
            .canvas .cropCurr .title {
                background-color: #00cc00b0;
                color: #ffffff;
                font-size: 4vw;
                font-weight: bold;
                padding: 0 2vw 1vw 1vw;
                border-bottom-right-radius: 2vw;
                position: absolute;
                top: 0;
                left: 0;
            }
            .canvas .cropCurr .info {
                background-color: #00cc00b0;
                color: #ffffff;
                font-size: 2vw;
                padding: 1vw 1vw 0 2vw;
                border-top-left-radius: 2vw;
                position: absolute;
                bottom: 0;
                right: 0;
            }
            .canvas .cropNext {
                position: absolute;
                display: flex;
                flex-direction: column;
                justify-content: top;
                align-items: center;
                box-sizing: border-box;
                border: 1vw solid #cc0000b0;
            }
            .canvas .cropNext .title {
                background-color: #cc0000b0;
                color: #ffffff;
                font-size: 4vw;
                font-weight: bold;
                padding: 0 2vw 1vw 1vw;
                border-bottom-right-radius: 2vw;
                position: absolute;
                top: 0;
                left: 0;
            }
            .canvas .cropNext .info {
                background-color: #cc0000b0;
                color: #ffffff;
                font-size: 2vw;
                padding: 1vw 1vw 0 2vw;
                border-top-left-radius: 2vw;
                position: absolute;
                bottom: 0;
                right: 0;
            }
            .canvas .protector {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
            .canvas .protector .title {
                position: absolute;
                top: 2vw;
                left: 2vw;
                padding: 1vw 2vw 1vw 2vw;
                background-color: #666666b0;
                color: #ffffff80;
                font-weight: bold;
                border-radius: 1vw;
                font-size: 3vw;
            }
        </style>
    </head>
    <body>
        <!-- <img class="img" v-bind:src="imgData"> -->
        <div class="canvas" ref="canvas"
            v-on:click="mouseClickLeft"
            v-on:contextmenu.prevent="mouseClickRight"
            v-on:mouseMove="mouseMove"
            v-on:mouseLeave="mouseLeave"
            v-on:wheel="mouseWheel"
            v-bind:style="{
                width:  dispCanvasW + 'px',
                height: dispCanvasH + 'px'}">
            <img v-bind:src="previewImg" ref="preview" class="preview" v-show="previewImg !== '' && previewShow">
            <div class="cropCurr" ref="cropCurr"
                v-bind:class="{ dragging: dragging }"
                v-bind:style="{
                    left:   dispCropCurrX + 'px',
                    top:    dispCropCurrY + 'px',
                    width:  dispCropCurrW + 'px',
                    height: dispCropCurrH + 'px' }">
                <div class="title" v-show="dispCropCurrW > 400" ref="cropCurrTitle">{{ title }}</div>
                <div class="info" v-show="dispCropCurrW > 400">
                      {{ Math.round(dispCropCurrX / dispScale) }}
                    : {{ Math.round(dispCropCurrY / dispScale) }}
                    / {{ Math.round(dispCropCurrW / dispScale) }}
                    x {{ Math.round(dispCropCurrH / dispScale) }}
                </div>
            </div>
            <div class="cropNext" ref="cropNext" v-show="dragging || progressing"
                v-bind:style="{
                    left:   dispCropNextX + 'px',
                    top:    dispCropNextY + 'px',
                    width:  dispCropNextW + 'px',
                    height: dispCropNextH + 'px' }">
                <div class="title" v-show="dispCropNextW > 400">{{ title }}</div>
                <div class="info" v-show="dispCropNextW > 400">
                      {{ Math.round(dispCropNextX / dispScale) }}
                    : {{ Math.round(dispCropNextY / dispScale) }}
                    / {{ Math.round(dispCropNextW / dispScale) }}
                    x {{ Math.round(dispCropNextH / dispScale) }}
                </div>
            </div>
            <div class="protector" ref="protector" v-show="progressing">
                <div class="title">PROGRESSING</div>
            </div>
            <div class="toolbar">
                <div v-for="define of defines" v-on:click="setDefine(define)" class="define"
                >{{ define.D }}</div>
                <div v-on:click="previewShow = !previewShow" class="button">
                    <span v-show="previewShow"><i class="fas fa-eye"></i></span>
                    <span v-show="!previewShow"><i class="fas fa-eye-slash"></i></span>
                </div>
            </div>
        </div>
    </body>
    <script type="text/javascript">
        const app = {
            data () {
                return {
                    obs:               null,
                                       
                    canvasW:           0,
                    canvasH:           0,
                    canvasR:           0,
                    sources:           [],
                    defines:           [],
                    title:             "",
                    cropX:             0,
                    cropY:             0,
                    cropW:             0,
                    cropH:             0,

                    duration:          1000,
                    fps:               30,

                    previewImg:        "",
                    previewShow:       false,
                                   
                    dispViewportW:     0, 
                    dispViewportH:     0, 
                    dispScale:         0,
                    dispCanvasW:       0,
                    dispCanvasH:       0,

                    dispCropCurrX:     0,
                    dispCropCurrY:     0,
                    dispCropCurrW:     0,
                    dispCropCurrH:     0,

                    dispCropNextX:     0,
                    dispCropNextY:     0,
                    dispCropNextW:     0,
                    dispCropNextH:     0,

                    dispDragPointerX:  0,
                    dispDragPointerY:  0,

                    dragging:          false,
                    progressing:       false,
                }
            },
            async mounted () {
                /*  parse options  */
                const params = {}
                for (const kv of document.location.href.replace(/^.*\?/, "").split(/\&/)) {
                    const [ , key, val ] = kv.match(/^(.*?)=(.*)$/)
                    params[key] = val
                }
                let m
                if (params.canvas === undefined)
                    throw new Error("missing \"canvas\" parameter")
                if ((m = params.canvas.match(/^(\d+)x(\d+)$/)) === null)
                    throw new Error("invalid \"canvas\" parameter")
                this.canvasW = parseInt(m[1])
                this.canvasH = parseInt(m[2])
                this.canvasR = this.canvasW / this.canvasH
                if (params.sources === undefined)
                    throw new Error("missing \"sources\" parameter")
                this.sources = params.sources.split(/,/)
                if (params.websocket === undefined)
                    params.websocket = "localhost:4444"
                if (params.password === undefined)
                    params.password = ""
                this.title = params.title
                if (this.title === "")
                    this.title = this.sources[0]
                if (params.duration !== undefined)
                    this.duration = parseInt(params.duration)
                if (params.fps !== undefined)
                    this.fps = parseInt(params.fps)
                if (params.define !== undefined) {
                    this.defines = params.define.split(/,/)
                    for (let i = 0; i < this.defines.length; i++) {
                        const m = this.defines[i].match(/^(\d):(\d+)\+(\d+)\/(\d+)x(\d+)$/)
                        if (m === null)
                            throw new Error(`invalid define specification "${this.defines[i]}"`)
                        this.defines[i] = {
                            D: m[1],
                            X: parseInt(m[2]), Y: parseInt(m[3]),
                            W: parseInt(m[4]), H: parseInt(m[5])
                        }
                    }
                }

                /*  connect to OBS Studio  */
                this.obs = new OBSWebSocket()
                this.obs.on("error", (err) => { console.error(`OBS Studio: ERROR: ${err}`) })
                await this.obs.connect({
                    address:  params.websocket,
                    password: params.password,
                    eventSubscriptions: 0
                })
                const version = await this.obs.send("GetVersion")
                console.log(`connected to: OBS Studio ${version.obsStudioVersion} / OBS WebSockets ${version.obsWebsocketVersion}`)

                /*  get initial cropping area  */
                const crop0 = await this.getCrop(this.sources[0])
                this.cropX = crop0.X
                this.cropY = crop0.Y
                this.cropW = crop0.W
                this.cropH = crop0.H
                for (const source of this.sources.slice(1))
                    this.getCrop(source)

                /*  determine display viewport size  */
                this.dispViewportW = window.innerWidth
                this.dispViewportH = window.innerHeight
                this.dispScale     = (this.dispViewportW / this.canvasW) 

                /*  determine display canvas size  */
                this.dispCanvasW = this.dispViewportW
                this.dispCanvasH = this.canvasH * this.dispScale

                /*  update display crop area  */
                this.dispCropCurrX = this.cropX * this.dispScale
                this.dispCropCurrY = this.cropY * this.dispScale
                this.dispCropCurrW = this.cropW * this.dispScale
                this.dispCropCurrH = this.cropH * this.dispScale

                /*  attach keystroke bindings  */
                for (const define of this.defines) {
                    Mousetrap.bind(define.D, async () => {
                        this.setDefine(define)
                    })
                }

                /*  recognize changes  */
                this.onCropChange(this.sources[0], (crop) => {
                    if (!(this.cropX === crop.X &&
                        this.cropY === crop.Y &&
                        this.cropW === crop.W &&
                        this.cropH === crop.H)) {
                        /*  update knowledge about OBS Studio crop area  */
                        this.cropX = crop.X
                        this.cropY = crop.Y
                        this.cropW = crop.W
                        this.cropH = crop.H

                        /*  update display crop area  */
                        this.dispCropCurrX = this.cropX * this.dispScale
                        this.dispCropCurrY = this.cropY * this.dispScale
                        this.dispCropCurrW = this.cropW * this.dispScale
                        this.dispCropCurrH = this.cropH * this.dispScale
                    }
                })

                /*  support source preview  */
                if (params.preview) {
                    const m = params.preview.match(/^(.+):(\d+(?:\.\d+)?)$/)
                    if (m === null)
                        throw new Error(`invalid preview specification "${params.preview}"`)
                    const [ , sourceName, fps ] = m
                    const frequency = 1000 / parseFloat(fps)
                    setInterval(async () => {
                        if (!this.previewShow)
                            return
                        const ss = await this.obs.send("TakeSourceScreenshot", {
                            sourceName: sourceName,
                            embedPictureFormat: "jpeg",
                            compressionQuality: 30,
                            width:  this.dispCanvasW,
                            height: this.dispCanvasH
                        })
                        this.previewImg = ss.img
                    }, frequency)
                }
            },
            methods: {
                /*  callback for mouse left-click  */
                async mouseClickLeft (ev) {
                    if (!this.dragging) {
                        /*  start dragging  */
                        if (!(ev.target === this.$refs.cropCurr || ev.target === this.$refs.cropCurrTitle))
                            return
                        this.dragging = true

                        /*  make crop-next start at drop-current  */
                        this.dispCropNextX = this.dispCropCurrX
                        this.dispCropNextY = this.dispCropCurrY
                        this.dispCropNextW = this.dispCropCurrW
                        this.dispCropNextH = this.dispCropCurrH

                        /*  start tracking mouse position  */
                        const pointerX = ev.clientX
                        const pointerY = ev.clientY
                        this.dispDragPointerX = pointerX
                        this.dispDragPointerY = pointerY
                    }
                    else {
                        /*  stop dragging  */
                        this.dragging = false

                        /*  determine old and new crop position  */
                        let { x, y } = this.$refs.canvas.getBoundingClientRect()
                        const cropOld = {
                            X: this.cropX,
                            Y: this.cropY,
                            W: this.cropW,
                            H: this.cropH
                        }
                        const cropNew = {
                            X: Math.round((this.dispCropNextX - x) / this.dispScale),
                            Y: Math.round((this.dispCropNextY - y) / this.dispScale),
                            W: Math.round(this.dispCropNextW / this.dispScale),
                            H: Math.round(this.dispCropNextH / this.dispScale)
                        }
                        if (cropOld.X === cropNew.X &&
                            cropOld.Y === cropNew.Y &&
                            cropOld.W === cropNew.W &&
                            cropOld.H === cropNew.H)
                            return

                        /*  progress from old to new position and/or size  */
                        await this.progress(cropOld, cropNew)
                    }
                },

                /*  callback for mouse right-click  */
                mouseClickRight (ev) {
                    if (!this.dragging)
                        return
                    this.dragging = false
                },

                /*  callback for mouse movement  */
                mouseMove (ev) {
                    if (!this.dragging)
                        return

                    /*  update tracking mouse position  */
                    const pointerX = ev.clientX
                    const pointerY = ev.clientY
                    const deltaX = pointerX - this.dispDragPointerX
                    const deltaY = pointerY - this.dispDragPointerY
                    this.dispDragPointerX = pointerX
                    this.dispDragPointerY = pointerY

                    /*  update new control crop position  */
                    this.dispCropNextX += deltaX
                    this.dispCropNextY += deltaY
                    if (this.dispCropNextX < 0)
                        this.dispCropNextX = 0
                    if (this.dispCropNextX > this.dispCanvasW - this.dispCropNextW)
                        this.dispCropNextX = this.dispCanvasW - this.dispCropNextW
                    if (this.dispCropNextY < 0)
                        this.dispCropNextY = 0
                    if (this.dispCropNextY > this.dispCanvasH - this.dispCropNextH)
                        this.dispCropNextY = this.dispCanvasH - this.dispCropNextH
                },

                /*  callback for mouse wheel  */
                mouseWheel (ev) {
                    if (!this.dragging)
                        return

                    /*  resize crop  */
                    this.dispCropNextH += ev.wheelDelta
                    this.dispCropNextW += ev.wheelDelta * this.canvasR

                    /*  restrict size to lower/upper bounds  */
                    if (this.dispCropNextH < 100)
                        this.dispCropNextH = 100
                    if (this.dispCropNextH > this.dispCanvasH)
                        this.dispCropNextH = this.dispCanvasH
                    if (this.dispCropNextW < 100 * this.canvasR)
                        this.dispCropNextW = 100 * this.canvasR 
                    if (this.dispCropNextW > this.dispCanvasW)
                        this.dispCropNextW = this.dispCanvasW

                    /*  optionally move position to ensure the area is still within the canvas  */
                    if (0 <= this.dispCropNextX && this.dispDragPointerX <= this.dispCropNextX)
                        this.dispCropNextX = this.dispDragPointerX
                    if (0 <= this.dispCropNextY && this.dispDragPointerY <= this.dispCropNextY)
                        this.dispCropNextY = this.dispDragPointerY
                    if (this.dispCropNextX <= this.dispDragPointerX && this.dispCropNextX <= this.dispCanvasW)
                        this.dispCropNextX = this.dispDragPointerX
                    if (this.dispCropNextY <= this.dispDragPointerY && this.dispCropNextY <= this.dispCanvasH)
                        this.dispCropNextY = this.dispDragPointerY
                    if ((this.dispCropNextX + this.dispCropNextW) > this.dispCanvasW)
                        this.dispCropNextX = this.dispCanvasW - this.dispCropNextW
                    if ((this.dispCropNextY + this.dispCropNextH) > this.dispCanvasH)
                        this.dispCropNextY = this.dispCanvasH - this.dispCropNextH
                },

                /*  animate over time  */
                animate (duration, stepper) {
                    return new Promise((resolve, reject) => {
                        const tick = 1000 / this.fps
                        let count = 0
                        const countMax = Math.floor(duration / tick)
                        stepper(0)
                        let timer = setInterval(() => {
                            count++
                            if (count < countMax)
                                stepper((count * tick) / duration)
                            else {
                                stepper(1)
                                clearTimeout(timer)
                                resolve()
                            }
                        }, tick)
                    })
                },

                /*  progress from old to new position and/or size  */
                async progress (cropOld, cropNew) {
                    this.progressing = true
                    await this.animate(this.duration, async (t) => {
                        /*  determine new OBS Studio source crop position  */
                        const v = d3.easeCubicInOut(t)
                        this.cropX = cropOld.X + Math.round((cropNew.X - cropOld.X) * v)
                        this.cropY = cropOld.Y + Math.round((cropNew.Y - cropOld.Y) * v)
                        this.cropW = cropOld.W + Math.round((cropNew.W - cropOld.W) * v)
                        this.cropH = cropOld.H + Math.round((cropNew.H - cropOld.H) * v)

                        /*  determine new control crop position  */
                        this.dispCropCurrX = this.cropX * this.dispScale
                        this.dispCropCurrY = this.cropY * this.dispScale
                        this.dispCropCurrW = this.cropW * this.dispScale
                        this.dispCropCurrH = this.cropH * this.dispScale

                        /*  update OBS Studio source crop settings  */
                        for (const source of this.sources) {
                            const crop = await this.getCrop(source)
                            crop.X = this.cropX
                            crop.Y = this.cropY
                            crop.W = this.cropW
                            crop.H = this.cropH
                            this.setCrop(source, crop)
                        }
                    })
                    this.progressing = false
                },

                /*  progress to a pre-defined position and/or size  */
                async setDefine (define) {
                    if (this.progressing)
                        return

                    /*  determine old and new position and/or size  */
                    const cropOld = { X: this.cropX, Y: this.cropY, W: this.cropW, H: this.cropH }
                    if (cropOld.X === define.X &&
                        cropOld.Y === define.Y &&
                        cropOld.W === define.W &&
                        cropOld.H === define.H)
                        return

                    /*  progress from old to new position and/or size  */
                    this.dispCropNextX = define.X * this.dispScale
                    this.dispCropNextY = define.Y * this.dispScale
                    this.dispCropNextW = define.W * this.dispScale
                    this.dispCropNextH = define.H * this.dispScale
                    await this.progress(cropOld, define)
                },

                /*  listen to crop settings change of OBS Studio source  */
                async onCropChange (sourceName, onChange) {
                    const list = await this.obs.send("GetSourceFilters", { sourceName: sourceName })
                    const filter = list.filters.find((filter) => filter.type === "crop_filter")
                    if (filter === undefined)
                        throw new Error(`no Crop/Pad filter found on source "${sourceName}"`)
                    let ctx = {}
                    ctx.crop = this.getCrop(sourceName)
                    ctx.timer = setInterval(async () => {
                        if (this.progressing)
                            return
                        const crop = await this.getCrop(sourceName)
                        if (crop.X === ctx.crop.X &&
                            crop.Y === ctx.crop.Y &&
                            crop.W === ctx.crop.W &&
                            crop.H === ctx.crop.H)
                            return
                        ctx.crop.X = crop.X
                        ctx.crop.Y = crop.Y
                        ctx.crop.W = crop.W
                        ctx.crop.H = crop.H
                        onChange(crop)
                    }, 1000)
                    ctx.unsubscribe = () => {
                        if (ctx.timer !== null) {
                            clearTimeout(ctx.timer)
                            ctx.timer = null
                        }
                    }
                },

                /*  get crop settings of OBS Studio source  */
                async getCrop (sourceName) {
                    const list = await this.obs.send("GetSourceFilters", { sourceName: sourceName })
                    const filter = list.filters.find((filter) => filter.type === "crop_filter")
                    if (filter === undefined)
                        throw new Error(`no Crop/Pad filter found on source "${sourceName}"`)
                    const info = await this.obs.send("GetSourceFilterInfo", {
                        sourceName: sourceName,
                        filterName: filter.name
                    })
                    return {
                        X: info.settings.left,
                        Y: info.settings.top,
                        W: info.settings.cx,
                        H: info.settings.cy
                    }
                },

                /*  set crop settings of OBS Studio source  */
                async setCrop (sourceName, crop) {
                    const list = await this.obs.send("GetSourceFilters", { sourceName: sourceName })
                    const filter = list.filters.find((filter) => filter.type === "crop_filter")
                    if (filter === undefined)
                        throw new Error(`no Crop/Pad filter found on source "${sourceName}"`)
                    const info = await this.obs.send("GetSourceFilterInfo", {
                        sourceName: sourceName,
                        filterName: filter.name
                    })
                    info.settings.left = crop.X
                    info.settings.top  = crop.Y
                    info.settings.cx   = crop.W
                    info.settings.cy   = crop.H
                    await this.obs.send("SetSourceFilterSettings", {
                        sourceName: sourceName,
                        filterName: filter.name,
                        filterSettings: info.settings
                    })
                }
            }
        }
        Vue.createApp(app).mount("body")
    </script>
</html>
